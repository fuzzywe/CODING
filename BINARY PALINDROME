// C++ program to check if binary representation 
// of a number is palindrome
#include <bits/stdc++.h>
using namespace std;

// This function return the binary form of integer in string format
string bin(unsigned n)
{ string ans; 
	while(n > 0){
		ans = (to_string(n&1)) + ans;
		n >>= 1; 
	}
	
	return ans; 
}

// This function returns true if binary 
// representation of x is palindrome 
bool checkPalindrome( unsigned int n){
	string s1 = bin(n);
	string s2 = s1; 
	
	// reversing the string 1
	reverse(s2.begin(), s2.end());
	
	return s1 == s2; 
}

// Driver code
int main() {
	unsigned int x = 1 << 15 + 1 << 16; 
	cout << checkPalindrome(x) << endl; 
	x = 10; 
	cout << checkPalindrome(x) << endl; 
	return 0;
}
Time Complexity: O(log(x))
Auxiliary Space: O(X)



**BEST CASE**

// C++ Program to Check if binary representation 
// of a number is palindrome 
#include<iostream> 
using namespace std; 

// This function returns true if k'th bit in x 
// is set (or 1). For example if x (0010) is 2 
// and k is 2, then it returns true 
bool isKthBitSet(unsigned int x, unsigned int k) 
{ 
	return (x & (1 << (k - 1))) ? true : false; 
} 

// This function returns true if binary 
// representation of x is palindrome. 
// For example (1000...001) is palindrome 
bool isPalindrome(unsigned int x) 
{ 
	int l = 1; // Initialize left position 
	int r = sizeof(unsigned int) * 8; // initialize right position 

	// One by one compare bits 
	while (l < r) 
	{ 
		if (isKthBitSet(x, l) != isKthBitSet(x, r)) 
			return false; 
		l++; r--; 
	} 
	return true; 
} 

// Driver Code 
int main() 
{ 
	unsigned int x = 1 << 15 + 1 << 16; 
	cout << isPalindrome(x) << endl; 
	x = 1 << 31 + 1; 
	cout << isPalindrome(x) << endl; 
	return 0; 
} 
Time Complexity: O(x)
Auxiliary Space: O(1)



EXAMPLE

9 in binary is 1001, which is a palindrome (same forwards and backwards).
6 in binary is 110, which is not a palindrome.
Code Breakdown
We want to check whether the binary representation of a number is a palindrome.

Step 1: Check if a Specific Bit is Set (1)
This function checks if the k-th bit of the number x is set to 1.

cpp
Copy code
bool isKthBitSet(unsigned int x, unsigned int k) {
    return (x & (1 << (k - 1))) ? true : false;
}
How this works:
1 << (k - 1) shifts the bit 1 to the left by k-1 positions. This creates a "mask" with 1 only at the k-th position.
x & (1 << (k - 1)) does a bitwise AND with the number x and the mask. If the result is non-zero, it means that the k-th bit of x is 1.
Example:
If x = 9 (binary 1001), and we want to check the 4th bit (from the right, index 3), isKthBitSet(9, 4) checks whether the left-most 1 in 1001 is set.
Step 2: Compare Left and Right Bits
We want to check if the leftmost bit matches the rightmost bit, then move inward towards the middle.

cpp
Copy code
bool isPalindrome(unsigned int x) {
    int l = 1; // Initialize the left position (1st bit)
    int r = sizeof(unsigned int) * 8; // Rightmost bit position (for 32 bits, r=32)

    while (l < r) {
        if (isKthBitSet(x, l) != isKthBitSet(x, r)) {
            return false;
        }
        l++; // Move left pointer to the right
        r--; // Move right pointer to the left
    }
    return true;
}
Explanation:
l = 1 starts checking from the leftmost bit (bit 1).
r = 32 starts checking from the rightmost bit (bit 32, for a 32-bit number).
We use the isKthBitSet(x, l) function to compare the bit at the left pointer (l) with the bit at the right pointer (r).
If they match, we move inward (l++, r--), and continue.
If any mismatch is found, the number is not a palindrome.
If we check all the way through, and no mismatch is found, the number is a palindrome.
Step 3: Test with Example
Let's go through an example where x = 9 (binary 1001):

cpp
Copy code
int main() {
    unsigned int x = 9; // Binary: 1001
    cout << isPalindrome(x) << endl; // Expected output: 1 (true, it is a palindrome)
    return 0;
}
Binary of 9:

9 in binary is 1001.
How the check works:

Compare bit 1 (leftmost) with bit 4 (rightmost):
Both are 1.
Compare bit 2 with bit 3:
Both are 0.
Since all matching pairs are the same, the number is a palindrome.
Output: The output will be 1 (which means true), as 1001 is a palindrome.

Example with Non-Palindrome:
Now, let's check a number that is not a palindrome. Try x = 10 (binary 1010):

cpp
Copy code
int main() {
    unsigned int x = 10; // Binary: 1010
    cout << isPalindrome(x) << endl; // Expected output: 0 (false, it is not a palindrome)
    return 0;
}
Binary of 10:

10 in binary is 1010.
How the check works:

Compare bit 1 (leftmost) with bit 4 (rightmost):
The first bit is 0, and the last bit is 1. They don't match.
So, the function immediately returns false.
Output: The output will be 0 (which means false), as 1010 is not a palindrome.

